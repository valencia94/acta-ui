import {
  apiBaseUrl,
  s3Bucket,
  s3Region,
  cloudfrontUrl,
  cloudfrontDistributionId,
} from '@/env.variables';
import { getAuthToken } from '@/utils/fetchWrapper';

/**
 * üîß Constants
 */
export const BASE = apiBaseUrl || 'https://q2b9avfwv5.execute-api.us-east-2.amazonaws.com/prod';
export const S3_BUCKET = s3Bucket || 'projectplace-dv-2025-x9a7b';
export const AWS_REGION = s3Region || 'us-east-2';

/**
 * üß† Types
 */
export interface ProjectSummary {
  project_id: string;
  project_name: string;
  pm?: string;
  project_manager?: string;
  acta_last_generated?: string;
  [k: string]: unknown;
}

export interface TimelineEvent {
  hito: string;
  actividades: string;
  desarrollo: string;
  fecha: string;
}

export interface PMProject {
  id: string;
  name: string;
  pm: string;
  status: string;
  [key: string]: unknown;
}

export interface DocumentCheckResult {
  available: boolean;
  lastModified?: string;
  size?: number;
  s3Key?: string;
}

/**
 * ‚öôÔ∏è Authenticated fetch wrapper
 */
async function request<T = unknown>(
  endpoint: string,
  options: RequestInit & { auth?: boolean } = {}
): Promise<T> {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
    ...(options.headers || {}),
  };

  if (options.auth !== false) {
    const token = await getAuthToken().catch(() => undefined);
    if (token) headers['Authorization'] = `Bearer ${token}`;
  }

  const res = await fetch(`${BASE}${endpoint}`, {
    ...options,
    headers,
  });

  if (!res.ok) {
    const txt = await res.text().catch(() => res.statusText);
    throw new Error(`${endpoint} ‚Üí ${res.status}: ${txt}`);
  }

  if (options.method === 'HEAD') return undefined as unknown as T;
  if (options.redirect === 'manual') return res as unknown as T;
  return res.json() as Promise<T>;
}

/**
 * üìä Metadata endpoints
 */
export const getSummary = (id: string) => request<ProjectSummary>(`/project-summary/${id}`);
export const getTimeline = (id: string) => request<TimelineEvent[]>(`/timeline/${id}`);

/**
 * üìÑ Acta document generation + status
 */
export async function generateActaDocument(
  projectId: string,
  userEmail: string,
  userRole: 'pm' | 'admin' = 'pm'
) {
  const payload = {
    projectId,
    pmEmail: userEmail,
    userRole,
    s3Bucket: S3_BUCKET,
    s3Region: AWS_REGION,
    cloudfrontDistributionId: cloudfrontDistributionId || 'EPQU7PVDLQXUA',
    cloudfrontUrl: cloudfrontUrl || 'https://d7t9x3j66yd8k.cloudfront.net',
    requestSource: 'acta-ui',
    generateDocuments: true,
    extractMetadata: true,
    timestamp: new Date().toISOString(),
  };

  return request<{ message: string; success: boolean }>(
    `/extract-project-place/${projectId}`,
    {
      method: 'POST',
      body: JSON.stringify(payload),
    }
  );
}

export async function getSignedDownloadUrl(
  projectId: string,
  format: 'pdf' | 'docx'
): Promise<string> {
  const res = await request<Response>(
    `/download-acta/${projectId}?format=${format}`,
    {
      method: 'GET',
      redirect: 'manual',
    }
  );

  if (res.status !== 302) {
    const txt = await res.text().catch(() => res.statusText);
    throw new Error(`Download endpoint error ${res.status}: ${txt}`);
  }

  const url = res.headers.get('Location');
  if (!url) throw new Error('Missing Location header in 302 response');
  return url;
}

/**
 * ‚úÖ Check if document exists (HEAD + metadata)
 */
export async function checkDocumentInS3(
  projectId: string,
  format: 'pdf' | 'docx'
): Promise<DocumentCheckResult> {
  try {
    const metadata = await request<DocumentCheckResult>(
      `/check-document/${projectId}?format=${format}`,
      { method: 'GET' }
    );
    return { ...metadata, available: true };
  } catch {
    return { available: false };
  }
}

/**
 * üì¨ Approval flow
 */
export const sendApprovalEmail = (actaId: string, clientEmail: string) =>
  request<{ message: string }>(`/send-approval-email`, {
    method: 'POST',
    body: JSON.stringify({ actaId, clientEmail }),
  });

/**
 * üìÅ Project metadata queries
 */
export async function getProjectsByPM(pmEmail: string, isAdmin: boolean): Promise<PMProject[]> {
  return request<PMProject[]>(`/projects-for-pm?email=${encodeURIComponent(pmEmail)}&admin=${isAdmin}`);
}

export async function generateSummariesForPM(pmEmail: string): Promise<ProjectSummary[]> {
  return request<ProjectSummary[]>(`/project-summaries?email=${encodeURIComponent(pmEmail)}`);
}

export async function getAllProjects(): Promise<PMProject[]> {
  return request<PMProject[]>(`/all-projects`);
}

/**
 * üß™ Expose debug helpers in dev
 */
if (import.meta.env.DEV && typeof window !== 'undefined') {
  // @ts-ignore
  window.getSummary = getSummary;
  // @ts-ignore
  window.getTimeline = getTimeline;
  // @ts-ignore
  window.getDownloadUrl = getSignedDownloadUrl;
  // @ts-ignore
  window.sendApprovalEmail = sendApprovalEmail;
  // @ts-ignore
  window.getProjectsByPM = getProjectsByPM;
  // @ts-ignore
  window.fetchWrapper = request;
}
// Add to src/lib/api.ts (after moving)

export interface DocumentCheckResult {
  available: boolean;
  lastModified?: string;
  size?: number;
  error?: string;
}

export async function checkDocumentInS3(
  projectId: string, 
  format: 'pdf' | 'docx'
): Promise<DocumentCheckResult> {
  try {
    const exists = await documentExists(projectId, format);
    return { available: exists };
  } catch (error) {
    return { 
      available: false, 
      error: error instanceof Error ? error.message : 'Unknown error' 
    };
  }
}
