// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import { print, parse, GraphQLError, } from 'graphql';
import { ConsoleLogger } from '@aws-amplify/core';
import { getAmplifyUserAgent, AmplifyUrl, } from '@aws-amplify/core/internals/utils';
import { GraphQLAuthError, } from '../types';
import { isCancelError as isCancelErrorREST } from '@aws-amplify/api-rest';
import { post, cancel as cancelREST, updateRequestToBeCancellable, } from '@aws-amplify/api-rest/internals';
import { AWSAppSyncRealTimeProvider } from '../Providers/AWSAppSyncRealTimeProvider';
import { resolveConfig, resolveLibraryOptions } from '../utils';
const USER_AGENT_HEADER = 'x-amz-user-agent';
const logger = new ConsoleLogger('GraphQLAPI');
export const graphqlOperation = (query, variables = {}, authToken) => ({
    query,
    variables,
    authToken,
});
const isAmplifyInstance = (amplify) => {
    return typeof amplify !== 'function';
};
/**
 * Export Cloud Logic APIs
 */
export class InternalGraphQLAPIClass {
    /**
     * Initialize GraphQL API with AWS configuration
     * @param {Object} options - Configuration object for API
     */
    constructor(options) {
        this._api = {
            post,
            cancelREST,
            isCancelErrorREST,
            updateRequestToBeCancellable,
        };
        this._options = options;
        logger.debug('API Options', this._options);
    }
    getModuleName() {
        return 'InternalGraphQLAPI';
    }
    async _headerBasedAuth(amplify, authMode, additionalHeaders = {}) {
        const config = amplify.getConfig();
        const { region: region, endpoint: appSyncGraphqlEndpoint, apiKey, defaultAuthMode, } = resolveConfig(amplify);
        const authenticationType = authMode || defaultAuthMode || 'iam';
        let headers = {};
        switch (authenticationType) {
            case 'apiKey':
                if (!apiKey) {
                    throw new Error(GraphQLAuthError.NO_API_KEY);
                }
                headers = {
                    'X-Api-Key': apiKey,
                };
                break;
            case 'iam':
                const session = await amplify.Auth.fetchAuthSession();
                if (session.credentials === undefined) {
                    throw new Error(GraphQLAuthError.NO_CREDENTIALS);
                }
                break;
            case 'oidc':
            case 'userPool':
                try {
                    let token;
                    token = (await amplify.Auth.fetchAuthSession()).tokens?.accessToken.toString();
                    if (!token) {
                        throw new Error(GraphQLAuthError.NO_FEDERATED_JWT);
                    }
                    headers = {
                        Authorization: token,
                    };
                }
                catch (e) {
                    throw new Error(GraphQLAuthError.NO_CURRENT_USER);
                }
                break;
            case 'lambda':
                if (!additionalHeaders.Authorization) {
                    throw new Error(GraphQLAuthError.NO_AUTH_TOKEN);
                }
                headers = {
                    Authorization: additionalHeaders.Authorization,
                };
                break;
            case 'none':
                break;
            default:
                break;
        }
        return headers;
    }
    /**
     * to get the operation type
     * @param operation
     */
    getGraphqlOperationType(operation) {
        const doc = parse(operation);
        const definitions = doc.definitions;
        const [{ operation: operationType }] = definitions;
        return operationType;
    }
    /**
     * Executes a GraphQL operation
     *
     * @param options - GraphQL Options
     * @param [additionalHeaders] - headers to merge in after any `graphql_headers` set in the config
     * @returns An Observable if the query is a subscription query, else a promise of the graphql result.
     */
    graphql(amplify, { query: paramQuery, variables = {}, authMode, authToken }, additionalHeaders, customUserAgentDetails) {
        const query = typeof paramQuery === 'string'
            ? parse(paramQuery)
            : parse(print(paramQuery));
        const [operationDef = {}] = query.definitions.filter(def => def.kind === 'OperationDefinition');
        const { operation: operationType } = operationDef;
        const headers = additionalHeaders || {};
        // if an authorization header is set, have the explicit authToken take precedence
        if (authToken) {
            headers.Authorization = authToken;
        }
        switch (operationType) {
            case 'query':
            case 'mutation':
                const abortController = new AbortController();
                let responsePromise;
                if (isAmplifyInstance(amplify)) {
                    responsePromise = this._graphql(amplify, { query, variables, authMode }, headers, abortController, customUserAgentDetails);
                }
                else {
                    const wrapper = amplifyInstance => this._graphql(amplifyInstance, { query, variables, authMode }, headers, abortController, customUserAgentDetails);
                    responsePromise = amplify(wrapper);
                }
                this._api.updateRequestToBeCancellable(responsePromise, abortController);
                return responsePromise;
            case 'subscription':
                return this._graphqlSubscribe(amplify, { query, variables, authMode }, headers, customUserAgentDetails);
            default:
                throw new Error(`invalid operation type: ${operationType}`);
        }
    }
    async _graphql(amplify, { query, variables, authMode }, additionalHeaders = {}, abortController, customUserAgentDetails) {
        const { region: region, endpoint: appSyncGraphqlEndpoint, customEndpoint, customEndpointRegion, } = resolveConfig(amplify);
        // Retrieve library options from Amplify configuration
        const { headers: customHeaders, withCredentials } = resolveLibraryOptions(amplify);
        // TODO: Figure what we need to do to remove `!`'s.
        const headers = {
            ...(!customEndpoint &&
                (await this._headerBasedAuth(amplify, authMode, additionalHeaders))),
            /**
             * Custom endpoint headers.
             * If there is both a custom endpoint and custom region present, we get the headers.
             * If there is a custom endpoint but no region, we return an empty object.
             * If neither are present, we return an empty object.
             */
            ...((customEndpoint &&
                (customEndpointRegion
                    ? await this._headerBasedAuth(amplify, authMode, additionalHeaders)
                    : {})) ||
                {}),
            // Custom headers included in Amplify configuration options:
            ...(customHeaders &&
                (await customHeaders({
                    query: print(query),
                    variables,
                }))),
            // Headers from individual calls to `graphql`:
            ...additionalHeaders,
            // User agent headers:
            ...(!customEndpoint && {
                [USER_AGENT_HEADER]: getAmplifyUserAgent(customUserAgentDetails),
            }),
        };
        const body = {
            query: print(query),
            variables: variables || null,
        };
        let signingServiceInfo;
        /**
         * We do not send the signing service info to the REST API under the
         * following conditions (i.e. it will not sign the request):
         *   - there is a custom endpoint but no region
         *   - the auth mode is `none`, or `apiKey`
         *   - the auth mode is a type other than the types listed below
         */
        if ((customEndpoint && !customEndpointRegion) ||
            (authMode !== 'oidc' &&
                authMode !== 'userPool' &&
                authMode !== 'iam' &&
                authMode !== 'lambda')) {
            signingServiceInfo = null;
        }
        else {
            signingServiceInfo = {
                service: !customEndpointRegion ? 'appsync' : 'execute-api',
                region: !customEndpointRegion ? region : customEndpointRegion,
            };
        }
        const endpoint = customEndpoint || appSyncGraphqlEndpoint;
        if (!endpoint) {
            const error = new GraphQLError('No graphql endpoint provided.');
            throw {
                data: {},
                errors: [error],
            };
        }
        let response;
        try {
            const { body: responseBody } = await this._api.post({
                url: new AmplifyUrl(endpoint),
                options: {
                    headers,
                    body,
                    signingServiceInfo,
                    withCredentials,
                },
                abortController,
            });
            const result = await responseBody.json();
            response = result;
        }
        catch (err) {
            // If the exception is because user intentionally
            // cancelled the request, do not modify the exception
            // so that clients can identify the exception correctly.
            if (this.isCancelError(err)) {
                throw err;
            }
            response = {
                data: {},
                errors: [new GraphQLError(err.message, null, null, null, null, err)],
            };
        }
        const { errors } = response;
        if (errors && errors.length) {
            throw response;
        }
        return response;
    }
    /**
     * Checks to see if an error thrown is from an api request cancellation
     * @param {any} error - Any error
     * @return {boolean} - A boolean indicating if the error was from an api request cancellation
     */
    isCancelError(error) {
        return this._api.isCancelErrorREST(error);
    }
    /**
     * Cancels an inflight request. Only applicable for graphql queries and mutations
     * @param {any} request - request to cancel
     * @returns - A boolean indicating if the request was cancelled
     */
    cancel(request, message) {
        return this._api.cancelREST(request, message);
    }
    _graphqlSubscribe(amplify, { query, variables, authMode }, additionalHeaders = {}, customUserAgentDetails) {
        const config = resolveConfig(amplify);
        if (!this.appSyncRealTime) {
            this.appSyncRealTime = new AWSAppSyncRealTimeProvider();
        }
        return this.appSyncRealTime.subscribe({
            query: print(query),
            variables,
            appSyncGraphqlEndpoint: config?.endpoint,
            region: config?.region,
            authenticationType: authMode ?? config?.defaultAuthMode,
            apiKey: config?.apiKey,
            additionalHeaders,
        }, customUserAgentDetails);
    }
}
export const InternalGraphQLAPI = new InternalGraphQLAPIClass(null);
